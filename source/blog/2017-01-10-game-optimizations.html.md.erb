---
id: "post_6"
published: false
title:  "Tips For Optimizing Your Game"
blurb: "Checklist for ensuring maximum performance when developing your next game"
author: James Lowrey
tags: Games,Optimization
---

<span class="caps">R</span>ecently I made a [simple game](/blog/Creating-Birdu-Part-1.html) and was surprised to run into performance issues.
How to fix it?
I could invest my time in micro optimizations ([JS](https://medium.com/@xilefmai/efficient-javascript-14a11651d563?imm_mid=0eb24a#.v4qkvtyf3)), intensive graphical analysis ([GTAV](http://www.adriancourreges.com/blog/2015/11/02/gta-v-graphics-study/) and [DOOM](http://www.adriancourreges.com/blog/2016/09/09/doom-2016-graphics-study/)), or conflicting forum advice.
Eventually I discovered the issue, and also collected some broadly applicable optimization tips.
I hope it helps other devs, but just remember how demanding and diverse games are, there's no silver bullet for improving performance.
I'll start with broad advice, and narrow it down to directly applicable information.

>The key to making programs fast is to make them do practically nothing. ;-) - [Mike Haertel](https://lists.freebsd.org/pipermail/freebsd-current/2010-August/019310.html)


<%= partial "partials/article_links.erb", locals: {
    resources: "
- [Optimization Patterns](http://gameprogrammingpatterns.com/optimization-patterns.html)
- [10 Myths of Game Optimization](http://www.gamasutra.com/view/feature/130296/the_top_10_myths_of_video_game_.php)
- [Crowd Optimization in Planet Coaster](http://www.gamasutra.com/view/news/288020/Game_Design_Deep_Dive_Creating_believable_crowds_in_Planet_Coaster.php)
- [JavaScript optimizations](https://github.com/petkaantonov/bluebird/wiki/Optimization-killers)
- [Unity Graphics Optimization Tips](https://docs.unity3d.com/Manual/OptimizingGraphicsPerformance.html)
"
  } %>

##Profilers

Profilers are tools that track a program's usage of the CPU, GPU, memory allocation, frame rate, and other key metrics.
They are absolutely essential.
Software does not run in a vaccum, so sometimes your game's slowdown could be caused by abode checking for updates in the background, and you'll be sent on a wild goose chase.

Since my game was written with [Phaser](http://phaser.io/) and Javascript I used Chrome's Timeline tool to profile.
Below you can see the output of a short run of my game.
It looks pretty daunting at first glance, but I highlighted some areas that help break it down.
Other profilers act similarly, and by using it to find areas of poor performance you can find the the code causing it and hunt down optimization issues.

<%= partial "partials/image.erb", locals: {
    src: "chrome_timeline.png",
    alt: "Chrome Timeline in Birdu game",
    caption: "Chrome Timeline, zoomed in on small section" } %>

##Use the latest and greatest

Engines are constantly getting better, make sure yours is up-to-date.

Do some research into plugins and tools that can accompany your engine.
Stuff won't always be available, helpful, or as significant as advertised, but I feel I have to include this because incoporating [Crosswalk](https://crosswalk-project.org/) into my hybrid app dramatically improved game performance.

##Use Network Calls Asynchronously

When accessing the network, please do it in an asynchronous manner.
Synchonous operations execute one-after-another, while [asynchronous operations](http://stackoverflow.com/questions/748175/asynchronous-vs-synchronous-execution-what-does-it-really-mean) are pushed off to another [thread](https://en.wikipedia.org/wiki/Thread_(computing)) and allow the calling code to keep running.
Some languages make it possible to run network calls in the UI thread, once it starts the entire UI is frozen until the network call finishes.
Most commonly though, developers will wait to use network calls until the user clicks on something, and then will make the user wait for it to return.
Fetch this data early, and don't make people wait.
I've also seen games that have multiple loading screens, one for making server calls and another to load assets/images into RAM (preloading).
Combine those!

##Input/Output and Graphics

Between levels of the memory hierarchy there are [orders of magnitude differences](http://stackoverflow.com/questions/4087280/approximate-cost-to-access-various-caches-and-main-memory) in the time it takes to access data, so be sure you are using memory closer to the top.
Performance is commonly an aspect of data, not code.

<%= partial "partials/image.erb", locals: {
    src: "memory_hierarchy.gif",
    alt: "Memory Hierarchy",
    caption: "<a href=\"http://superuser.com/questions/78362/what-is-the-relationship-between-cpu-usage-and-ram/78364\">Source</a>" } %>

However, as a game programmer memory hierarchy is usually abstracted away from you by your engine and language of choice.
They handle and optimize for complicated things like garbage collection, draw calls, static/dynamic batching, and other rendering related buzzwords.
It's your job to make sure you don't tax these systems and use them in ways they are not prepared for.

First off, ensure your don't run out of memory by **using smaller assets**, or less of them.
Trying to load huge images, sounds, and files into memory will cause it to fill up fast and lead to abysmal performance.
Ensure that the **assets are optimized**.
Using a texture atlas or spritesheet instead of individual images will dramatically lower GPU draw calls and improve 2D performance.
Using 3D objects with less vertices or polygons will make collision detection and rendering many times faster.
Watch out for **asset decompression**.
For example, in my game Birdu mp3's induced a noticeable lag when starting while wav's did not.
There was less decompression required.
Next, **reduce game world size** to lower the amount that needs rendered at once.
Only render what the user can see and load more of the game world as needed.
In general, try to improve **data locality** to improve cache performance.
Read [this article](http://gameprogrammingpatterns.com/data-locality.html) to find out how.
This is a problem difficult to diagnosis and solve so just be wary of it and start debugging for it as a last ditch effort, it can yield great benefits.
Finally **read documentation** to find any engine-specific functions that can help improve performance.

GPU and graphics optimizations can get [super complicated and in-depth](http://www.adriancourreges.com/blog/2016/09/09/doom-2016-graphics-study/), so there is much more that you can optimize.
For most non-AAA games the above advice should be sufficient, but I will try to keep it updated as I learn more.

##Do Less Stuff

reduce code in update() loop (use timers?)
focus on optimizing functions that execute frequently

Cut down on expensive/complicated function calls by reusing their values after calling them the first time.
This is also known as caching, but is different from a memory cache (though both improve performance by storing intermediate values).

##Heroes Never Die

Creating objects is expensive (why?)
Recycle sprites! do not create and destroy stuff dynamically
pre-allocate sprites when starting game

##Algorithm Analysis

Meat-and-potatoes CSE: know your big-O notation, algorithmic complexities, and be extremely wary of loops.
Finding neighbors, paths, blank and blank are all common tasks in games that can dramatically benefit from data structures or better algorithm design.

##And beyond?
