---
id: "post_4"
published: false
title:  "Creating Birdu Part 2: Using the Generator"
blurb: "Utilize the generator to bootstrap a new project."
header: { img_url: "tech/phaser-logo.svg" }
author: James Lowrey
tags: Birdu,Phaser,Cordova,HTML5,Javascript
---

[<span class="caps">L</span>ast time](/blog/Creating-Birdu-Part-1.html) we gave an overview of Birdu's tech stack.
Now, we will use that stack to get started in our game.
Here will will cover the generator we'll be using, basic game setup, and the creation of a menu screen.

Please note, this tutorial aims to outline the main development processes involved, but not every nitty-gritty detail.
The final product will be slightly different than the Birdu game that is available online, if you want to know how to implement it exactly you should checkout its [code](https://github.com/JTronLabs/Birdu).

<%= partial "partials/article_links.erb", locals: {
    resources: "
- [Birdu Repo](https://github.com/JTronLabs/Birdu)
- [Birdu on Google Play](https://play.google.com/store/apps/details?id=com.jtronlabs.birdu)
- [Phaser Repo](https://github.com/photonstorm/phaser)
- [Phaser Docs](https://phaser.io/docs/)
- [Phaser Examples](https://phaser.io/examples)
- [Phaser Examples Repo](https://github.com/photonstorm/phaser-examples)
- [Phaser 2.0 Tutorial - Flappy Bird](http://www.codevinsky.com/phaser-2-0-tutorial-flappy-bird-part-1/)
",
    software_versions: "
- [Ubuntu 16.04 LTS](http://www.ubuntu.com/download)
- [Phaser.js 2.6.2](http://phaser.io/docs/2.6.2/index)
- [Cordova 6.4.0](https://cordova.apache.org/docs/en/latest/)
- [Node 4.2.6](https://nodejs.org/en/)
- [NPM 3.5.2](https://www.npmjs.com/)
- [Generator Phaser Plus 1.1.0](https://github.com/rblopes/generator-phaser-plus)
"
  } %>

##Generate!

Let's get to it! First Step, open up a terminal and install the [generator](https://github.com/rblopes/generator-phaser-plus).

~~~ bash
npm install --global yo                     # To install Yeoman.
npm install --global generator-phaser-plus  # To install the generator & dependencies. Takes a little while.

mkdir birdu && cd $_                        # Make a folder and enter into it
yo phaser-plus                              # Generate!
~~~

The generator will ask for your game's name ("Birdu"), a description ("Best game ever made"), desired physics system (Arcade Only), and a dev preference (Babel & ECMASCript modules).
For physics, Phaser supports Arcade, Ninja, and P2 physics.
In that order they [increase in customizability, but decrease in performance](http://gamedev.stackexchange.com/questions/72930/difference-between-arcade-p2-and-ninja-physics-in-phaser).
Your physics system will vary based upon your goals and desire gameplay.
Birdu is simple. It treats all the birds as rectanges and collision is a simple (and fast) [AABB](http://stackoverflow.com/questions/22512319/what-is-aabb-collision-detection).
As you level up in development skill, you may eventually need a different physics engine.

The "develop preference" question refers to how you choose to manage your [JS dependencies](https://github.com/rblopes/generator-phaser-plus/blob/7614a54678f4d461de1c98a6fffd9f99fb562ba3/docs/managing-dependencies.md) in your project.
CommonJS uses "require" to import and use discrete JS modules, while the 2015 ECMAScript paradigm uses "import" (and Babel to make your code backwards compatible).
ECMA is newer and built-in to the language, so we'll be using that.

Anyways, the generator takes your answers, inserts the title & description text in the desired places, downloads & integrates your physics engine (it's modular), and starts the long process of downloading all your node dependencies to the node_modules folder.
The final output will look something like this

~~~ bash
├── gulpfile.js         #Gulp code responsible for building project
│   │
│   ├── lib             #Specific module configuration
│   │   └── bundler.js  #Browserify/Watchify support module
│   │
│   ├── tasks           #Gulp execution tasks/commands
│   │   ├── dev.js      #Dev build process
│   │   └── dist.js     #Distribution/Production build process
│   │
│   ├── config.js       #Config - Specify folder/file locations, module behaviors, etc
│   └── index.js        #Tie it all together!
│
├── node_modules        #Project dependencies
│   └── ...             #Seriously lots of dependencies
│
├── src                 #This is our game code!
│   │
│   ├── objects         #Main player, JumpingEnemy, Logo are all game objects. This is where bulk of the code will live
│   │   └── ...
│   │
│   ├── states          #Different screens/displays of the game
│   │   ├── Boot.js
│   │   ├── Preload.js  #Some example states are included in the initial generation
│   │   └── Game.js
│   │
│   ├── app.js          #Called from index.html to create, start, and adds states to Phaser's 'game' object
│   ├── assets.js       #JSON describing how to preload assets from the 'static/assets' directory
│   └── states.js       #List of all game states. Auto-updated if using generator to create states (covered soon)
│
├── static              #Static files that do not directly interact with game code. Examples: Game assets, web app assets, web pages, and more
│   │
│   ├── assets          #Game assets: images, music, JSON, etc
│   │   └── ...
│   │
│   ├── index.html      #HTML that our game will live in! It will be copied to the build output.
│
├── .babelrc            #Babel        (compiles code to old JS versions)                    options
├── .editorconfig       #EditorConfig (maintains styles between disparate editors & IDEs)   options
├── .eslintrc.yml       #ESLint       (catches JS errors, enforces JS style, runs in Gulp)  options
├── .gitattributes      #Special instructions for using & customizing Git. I've never had to use it
├── .gitignore          #Specifies files you don't want to check into your remote Git repository
├── .yo-rc.json         #Our generator's Yeoman config. Allows generator to remember customization info from prompts, and use it in future
├── package.json        #NPM customization. Choose dev & production dependencies, specify NPM package meta info, writes scripts, and more
└── README.md           #Describe to consumers how to use and grok your software. A quick-start guide.
~~~

Whew!

##Generator Output

The code block above is the quick reference guide to the generator output, but some things could use a bit more explanation.

###gulpfile.js

This contains all of our javascript compilation logic.
The 'tasks' subdirectory is what you'll likely end up configuring if you add new development or production dependencies.
These files are currently set to wipe out the build output, minify files, bundle JS together into one file, and copy assets to build dir.
I did not have to modify anything for Birdu.

###node_modules

This houses all of our node project dependencies.
These dependencies are configured in 'package.json', and can be installed by running `npm install`.
Some people think you should check in dependencies to your VCS in case they get [yanked off of NPM](http://www.theregister.co.uk/2016/03/23/npm_left_pad_chaos/), but this is a relatively rare occurrence.
By default, .gitignore is set to not commit your dependencies.
If you choose to commit it, you will massively inflate your VCS files, compounding each time any dependency updates.
In the rare case something goes down, the NPM community will quickly add a [mirror or replacement](http://blog.npmjs.org/post/141577284765/kik-left-pad-and-npm).

###src

You guessed it, here's where the source code lives.
The 'states' folder contains [States](http://phaser.io/docs/2.6.2/Phaser.State.html): basically a screen or display in game.
In order of usage, Birdu will contain Boot, Preload, Menu, Settings, Stats, Game, and GameOver.
Each state has a clearly defined purpose (Boot and Preload load assets & display distractions while the user has to wait) and may contain a variety of objects.
The 'objects' folder contains prefabs that you can import into a given State.
An object could be an simple, static Logo, or your glorious game player with rich handling of user interactions, varied animations, complex game logic, etc.
Objects allow us to separate code unrelated to State execution into self-contained, modular components.

###static



##Sub-Generators
