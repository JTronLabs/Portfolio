---
id: "post_2"
title:  "Creating Birdu Part 1: The Tech Stack"
blurb: "In preparation for creating Birdu, an HTML5 game, we will examine our tech stack and give background on the project."
header: { img_url: "tech/phaser-logo.svg" }
author: James Lowrey
tags: Birdu,Phaser,Cordova,HTML5,Javascript
---

<span class="caps">H</span>TML5 games have come [a long way](http://js-kongress.de/current-state-html5-game-development-2016/) in the past few years.
As the tech continues to progress it becomes possible to make gameplay more complex, but first you have to learn the basics!
In this tutorial series, I'll cover how to make a 2-D game, [Birdu](https://github.com/JTronLabs/Birdu).
The objective of Birdu is to eat small birds, and avoid being eaten by large ones.
This post examines the tech stack behind Birdu and how the pieces all fit together.

This tutorial is great for people interested in Phaser, gamedev and even front-end tools.
It's made for all experience levels, but may be a bit biased towards beginners.

![Birdu Preview](/images<%= current_article.url %>/birdu-preview.gif)

<%= partial "partials/article_links.erb", locals: {
    resources: "
- [Birdu Repo](https://github.com/JTronLabs/Birdu)
- [Birdu on Google Play](https://play.google.com/store/apps/details?id=com.jtronlabs.birdu)
- [Phaser Repo](https://github.com/photonstorm/phaser)
- [Phaser Docs](https://phaser.io/docs/)
- [Phaser Examples](https://phaser.io/examples)
- [Phaser Examples Repo](https://github.com/photonstorm/phaser-examples)
- [Phaser 2.0 Tutorial - Flappy Bird](http://www.codevinsky.com/phaser-2-0-tutorial-flappy-bird-part-1/)
",
    software_versions: "
- [Ubuntu 16.04 LTS](http://www.ubuntu.com/download)
- [Git 2.10.2](https://git-scm.com/)
- [Phaser.js 2.6.2](http://phaser.io/docs/2.6.2/index)
- [Cordova 6.4.0](https://cordova.apache.org/docs/en/latest/)
- [Node 4.2.6](https://nodejs.org/en/)
- [NPM 3.5.2](https://www.npmjs.com/)
- [Generator Phaser Plus 1.1.0](https://github.com/rblopes/generator-phaser-plus)"
  } %>

<iframe width="560" height="315" src="https://www.youtube.com/embed/FwgmTebXOqc" frameborder="0" allowfullscreen></iframe>

##Git

![Git](/images/tech/git.svg)
{: .icon }

Git is a [Version Control System](https://en.wikipedia.org/wiki/Version_control).
VCS's track changes to your source documents and maintain your sanity.
They are absolutely ESSENTIAL to development: providing backups, repository (repo) versioning, differential comparisons of code files, and more.
And they're *free.
[GitHub](https://github.com/), [GitLab](https://about.gitlab.com/), and [BitBucket](https://bitbucket.org/) are the big boys using the Git protocol.
I recommend GitHub for public repos due to its large community, but GitLab for free private repos and rapidly growing features.

There are other VCS protocols like SVN, Mercurial, Bazaar, etc.
Git is really the go-to though, it has a [huge community](http://softwareengineering.stackexchange.com/questions/96933/why-did-git-get-so-much-hype-while-others-dont), gentle learning curve, powerful features, and near-ubiquitous presence in universities.

*Public repos are free on GitHub & GitLab. Private repos are free on GitLab. Public & private repos are free for small teams (less than 5) on BitBucket.

##Linux

![Linux](/images/tech/NewTux.svg)
{: .icon }

[Linux](https://en.wikipedia.org/wiki/Linus) is a completely free and open-source operating system ([available on GitHub](https://github.com/torvalds/linux)).
It runs most of the world's servers, powers Android, and has Tux the penguin.
Linux has been integral to community development for a long time, and a ton of community software will only be tested on Linux devices.

You could develop your Phaser game entirely in Windows or Mac, but I (Alert: opinion incoming) wouldn't recommend.
Usually you want to develop on the OS you're targeting, but the Web is platform independent.
So I choose to use what makes development easiest, and that's Linux.
Mac would be easier, as it shares a common ancestor with Linux, but it likely will still cause problems down the road.
If you have a Mac or Windows machine, I would recommend using [VirtualBox](https://www.virtualbox.org/wiki/VirtualBox) to run an isolated, local [VM](https://en.wikipedia.org/wiki/Virtual_machine) for development.
Or, if you're comfortable messing with your hard drive partitions, you can setup a [dual boot system](http://www.makeuseof.com/tag/reasons-dual-boot-linux/).

##HTML5 & JS

![HTML5](/images/tech/HTML5.svg)
{: .icon }

![JavaScript](/images/tech/javascript.svg)
{: .icon }

Many big game companies program in a platform-specific manner to acheive performant games, or due to special deals they've made to be exclusives.
Indie developers don't have the ability to make these deals, nor as strict performance needs in a 2-D world.
It's more beneficial to increase your audience, lower dev time, and have maintainable code.
HTML5 allows you to write code once and target all web, mobile and desktop platforms.
I'll cover how to publish on mobile devices with Cordova at the end of this tutorial series.

Depending on the engine you use, making HTML5 games can also help you become a better web developer.
When using Phaser.js there is a lot of cross-over in the tools used for game-dev and the tools you'd use in front-end work.
Node, NPM, Grunt, ES6, etc. You will also be prototyping in the browser and developing for a fragmented audience.
Using these build tools and JS libraries allow us to create a game that is faster and smaller than is possible in current-gen game engines like Unity or UE4.

##Phaser.js

![Phaser.js](/images/tech/phaser-logo.svg)
{: .icon }

[Phaser](http://phaser.io/) is a lightweight 2-D game engine that is free and [Open-Source](https://github.com/photonstorm/phaser).
Free is always a plus.
Being open-source allows you to debug at all levels of the stack, while closed source engines [can complicate things](http://stephaniehurlburt.com/blog/2016/9/16/closed-source-engines-are-a-big-risk).
This allows you to know exactly what the engine is doing by examining its code on GitHub, instead of having to make an educated guess from documentation (e.g. Unity3D).

I have heard that on mobile Unity and UE4 can have [large packages and be inefficient](https://www.slant.co/versus/1047/1065/~unity_vs_phaser-io), with Unity appearing to be [slightly better](http://www.makinggames.biz/feature/unreal-vs-unity-which-engine-is-better-for-mobile-games,8472.html).
In addition, their GUIs can be awkward to use for 2D work. Meanwhile, Phaser doesn't have an annoying GUI (though I think the [paid editor](http://phasereditor.boniatillo.com/) does - it's not needed), only adds itself to the build output, and is wholly optimized for the browser and 2D Gaming.
One of Phaser's greatest strengths is the [documentation](http://phaser.io/docs/2.4.7/index).
The [offical tutorials](http://phaser.io/learn/official-tutorials), [community tutorials](http://phaser.io/learn/community-tutorials), and [specific examples](http://phaser.io/examples) give this engine a gentle learning curve, ultimately making your game quicker (and cheaper) to make.
Just compare [LibGDX's](https://libgdx.badlogicgames.com/nightlies/docs/api/) API to [Phaser's](https://phaser.io/docs/2.6.2/index).

Phaser is the [most popular](https://github.com/showcases/javascript-game-engines) open source JS game engine.
It's not perfect though. Since it's built on top of [Pixi](https://github.com/pixijs/pixi.js), some functions can be confusing.
For example, Group.addChild is a Pixi method and Group.add is a Phaser method. These usually end up being just minor annoyances though.
If something in the docs can be improved you can contribute back to the community by submitting a pull request to the Phaser repository.
Phaser adds [a lot on top](http://www.html5gamedevs.com/topic/12656-phaser-pixi/) of Pixi: a variety of physics engines, a game world with pannable camera, Tilemap support, particle systems, etc.
The next iteration of Phaser is currently in the works, [Lazer](http://phaser.io/news/2016/01/phaser-in-2015-and-beyond) (scroll down to "Lazer (aka Phaser 3)"), which will remove Pixi and add a whole bunch of new goodies.
Even with Lazer coming up, Phaser will still be around for a long time.

##Cordova

![Cordova](/images/tech/cordova.svg)
{: .icon }

[Cordova](https://cordova.apache.org/) is the magic glue that allows us to stick all platforms to one code base.
Cordova was [originally named PhoneGap](https://en.wikipedia.org/wiki/Apache_Cordova) until open sourced and released by Adobe, now it is maintained by the Apache foundation.
[PhoneGap](http://phonegap.com/) now runs on Cordova, offering some extra goodies (like cloud compiling) on top.
There are actually a lot of platforms to make hybrid apps: Cordova, PhoneGap, Ionic, React-Native, and more.
I choose to use Cordova as it has the biggest community and allows me to pivot to similar platforms (like PhoneGap or Ionic) if desired.
Community is always a hugely important consideration. It ensures software will be maintained going into the future, and that there are people knowledgable on your issues out in the world.

As stated in the opening paragraph, making hybrid apps has a performance hit.
Generally they take a bit longer to open and use more RAM than a native application.
[These stats](https://taco.visualstudio.com/en-us/docs/cost-cordova/) are indictative of what you might see, but are also over a year old. Things have gotten better.
From my testing, I can say that hybrid apps are quite "snappy", and "performant". I didn't notice any big troubles with Birdu.
I also used [Cordova Crosswalk](https://crosswalk-project.org/), which allows you to use the newest Chrome version on your hybrid apps instead of the platform's default WebView.
This can really [boost performace](https://taco.visualstudio.com/en-us/docs/cost-cordova/) and allow you to only target the newest web APIs.

##Node and NPM

![Node](/images/tech/node.svg)
{: .icon }

![NPM](/images/tech/Npm-logo.svg)
{: .icon }

***We are now entering the land of Node and its tools.*** It may get a [bit confusing](https://hackernoon.com/how-it-feels-to-learn-javascript-in-2016-d3a717dd577f#.nl1ilwi5m), but it is [managable](https://medium.com/@kitze/how-it-actually-feels-to-write-javascript-in-2016-46b5dda17bb5#.9tbq3micz).
Hang in there.
You don't need perfect knowledge of all these tools to start on your game.

So...Node. So hot right now.

Node is JavaScript for the server.
It's prides itself on being event based, instead of thread based.
Basically, Node doesn't make threads wait on I/O, which makes it scalable.
I'm not a Node expert though, as I've never used it to build a web server.
For making Birdu and other Phaser games we're more interested in the Node Package Manager (NPM).
NPM is a massive collection of tools written in JavaScript that you are free to use. [Very similar to Ruby's Gems](https://www.quora.com/How-does-npm-compare-to-other-packaging-systems-like-Ruby-gems-and-Pythons-pip).
Many of these tools use Node (hence the NPM name). Many don't (like [Phaser](https://www.npmjs.com/package/phaser)).
NPM allows us to use a file, package.json, to manage project dependencies, both for development (like Cordova) and production (like Phaser).
There are a TON of extremely awesome open source projects on NPM.
[D3.js](https://www.npmjs.com/package/d3), [Phaser](https://www.npmjs.com/package/phaser), [Cordova](https://www.npmjs.com/package/cordova),
[express](https://www.npmjs.com/package/express), [React](https://www.npmjs.com/package/react), [Passport](https://www.npmjs.com/package/passport), to just name a few.
However, NPM isn't the only place to get these projects. You can download them directly off the project's website or off their GitHub repos.
What NPM does do is it allows us to easily manage many dependiences all in one place, our package.json.
As you get a bit deeper, you'll find that there's [even more you can manage](https://docs.npmjs.com/files/package.json) with the package.json.

##Generator-Phaser-Plus

![Generator-Phaser-Plus](/images/tech/phaser-plus.png)
{: .icon }

[Generator-Phaser-Plus](https://github.com/rblopes/generator-phaser-plus) is a [Yeoman](http://yeoman.io/) generator that will output the intial skeleton of our game.
Its maintainer, [RBlopes](https://github.com/rblopes) did all the hard work of finding the relevant NPM dependencies, linking them together, and making an easy to use API to generate the game.
To make his project usable for a wider audience, he didn't include Cordova though. I will cover the process of adding it in a later post.
The rest of the tools I'm going to cover below are already set up in the generator's output, and likely won't require much configuration.
But it's still good info to know if you intend to break out of the given mold.

##Gulp

![Gulp](/images/tech/gulp.svg)
{: .icon }

[Gulp](http://gulpjs.com/), [Grunt](http://gruntjs.com/) and [NPM scripts](https://medium.freecodecamp.com/why-i-left-gulp-and-grunt-for-npm-scripts-3d6853dd22b8) can all be used to build a JavaScript project.
There are a lot of [opinions](http://wisdomgeek.com/web-development/grunt-vs-gulp-vs-npm/) on which is best, and you can get lost down a rabbit-hole of research for choosing the perfect tool.
You'll notice this is a common theme in Node: similar tools with relatively subtle differences that perform comparably.
Gulp is newer than Grunt, supposedly faster, and has a similarly sized community.
Both are considered to be simpler than NPM scripting.
We'll use Gulp because it's already setup in the generator.
In a simple web page (like this one) you may be able to write a few functions for hiding/showing elements, include it in the `<head>` and be done.
No build or complex integration required.
As your projects increase in complexity, you'll want to create small, [modular](https://en.wikipedia.org/wiki/Modular_design) files (components), and import them to their consuming components.
Building allow you to take advantage of tools that can automatically [bundle files](https://www.asp.net/mvc/overview/performance/bundling-and-minification), [minify files](https://en.wikipedia.org/wiki/Minification_(programming)), [preprocess css](https://en.wikipedia.org/wiki/Preprocessor) (e.g. with [SASS](http://sass-lang.com/)), spin up a local server, and [more](https://css-tricks.com/gulp-for-beginners/).

##Babel

![Babel](/images/tech/babel.svg)
{: .icon }

[Babel](https://babeljs.io/) is a step in the compilation/[transpiling](https://www.stevefenton.co.uk/2012/11/compiling-vs-transpiling/) process that ensures you can use modern JavaScript.
This allows you to include all of the fancy new features of [ES6/ECMAScript2015](https://benmccormick.org/2015/09/14/es5-es6-es2016-es-next-whats-going-on-with-javascript-versioning/)
(like [classes](http://es6-features.org/#ClassDefinition), [arrow functions](http://es6-features.org/#ExpressionBodies), [promises](http://es6-features.org/#PromiseUsage), and much [more](http://es6-features.org/#Constants)),
and end up with code compiled to an older version of JavaScript, compatible with all browsers.
As ECMAScript/JavaScript continues to evolve, Babel will let you incorporate the most up-to-date syntax in your development, while simultaneously maintaining wide browser support.

##Browsersync

![Browsersync](/images/tech/browsersync.svg)
{: .icon }

[Browsersync](https://browsersync.io/) is used in this project to create a local server that refreshes automatically upon file changes.
Phaser [requires a server](https://phaser.io/tutorials/getting-started/index) to work, and Browsersync conveniently makes that possible.
The generator gives us this for free, but Browsersync is capable of more.
To name a few: click & interaction mirroring, simulated network throttling, maintaining URL history across test devices, etc.
Check out their website.

##ESLint

![ESLint](/images/tech/eslint.svg)
{: .icon }

[ESLint](http://eslint.org/) is one of many JavaScript [linters](https://en.wikipedia.org/wiki/Lint_(software)): utilities that check your code for potential bugs and deviations from a style guide.
Notably, other linters include JSLint, JSHint, JSCS, and of course, ESLint.
ESLint is [the best](https://www.sitepoint.com/comparison-javascript-linting-tools/) as it comes with default configuration yet is highly extensible.
It also supports [JSX](https://jsx.github.io/) (though that's not relevant to us) and ES6 (relevant to us).
Linters are awesome.
They make your code more consistent, maintainable, and fun to read.
If you haven't used one before, prepare for JS to become a lot easier (and to be annoyed by minor formatting errors - sorry).

##Atom

![Atom](/images/tech/atom.svg)
{: .icon }

[Atom](https://atom.io/) is not a build tool, it is a text editor/IDE lite.
It feels like we're in the middle of WEW II, World Editor Wars 2, between Atom, [VSCode](https://code.visualstudio.com/), and to a lesser extent, [Brackets](http://brackets.io/).
The [first war](https://en.wikipedia.org/wiki/Editor_war) never really finished, but was merely left at a ceasefire.
I suppose a second one was inevitable.

Atom is my personal choice.
All are good choices, though Brackets is geared more towards front-end work; it feels more like a text-editor than an IDE-lite.
VSCode gets a lot of love as the Microsoft team continues to add more features and maintain a tool with a clear performance edge.
Atom however, has a vibrant community with over 5,000 home-grown, easy to use plug-ins.
I keep my favorites up-to-date [here](https://gist.github.com/JTronLabs/941821b71a746dc31f418fd03a6c7236).
They include a file mini-map, auto-completion of HTML tags, linting in-editor, auto-beautification upon saving, in-editor terminals (my favorite), and much more.
I'm sure a lot of this is also availble in VSCode, the big difference being their package manager is a ["Marketplace"](https://marketplace.visualstudio.com/) while Atom's is just a [collection](https://atom.io/packages).
I would guess that Atom's performance continues to improve, and their plug-ins stay community driven, open source, and far ahead of VSCode.

##That's all folks

[Next time]((/blog/Creating-Birdu-Part-2.html)) I'll be covering the set up and execution of a basic Phaser game.
Thanks for stopping by!
